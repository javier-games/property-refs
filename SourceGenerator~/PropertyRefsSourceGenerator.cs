using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.IO;
using System.Text;

namespace Monogum.BricksBucket.PropertyRefs.SourceGenerator
{
	[Generator]
	public class HardwiredRegistryGenerator : ISourceGenerator
	{
		private const string FileName = "Registry.PropertyRefsSourceGenerator.additionalfile";
		private const string NameSpace = "Monogum.BricksBucket.PropertyRefs.Hardwire";
		private const string ClassName = "HardwiredRegistry";
		
		public void Execute(GeneratorExecutionContext context)
		{
			var moduleName = context.Compilation.SourceModule.Name;
			if (moduleName.StartsWith("UnityEngine.")) return;
			if (moduleName.StartsWith("UnityEditor.")) return;
			if (moduleName.StartsWith("Unity.")) return;
			if (!moduleName.StartsWith("Monogum.")) { return; }
			
			var additionalFiles = context.AdditionalFiles;
			AdditionalText registryAdditionalFile = null;
			
			foreach (var additionalFile in additionalFiles)
			{
				if (!additionalFile.Path.Contains(FileName)) { continue; }
				registryAdditionalFile = additionalFile;
				break;
			}

			if (registryAdditionalFile == null)
			{
				return;
			}

			var jsonText = File.ReadAllText(registryAdditionalFile.Path);
			if (string.IsNullOrEmpty(jsonText))
			{
				jsonText = JsonUtils.Serialize(new RegistryData(){components = new RegisteredComponent[]{}});
				File.WriteAllText(registryAdditionalFile.Path, jsonText);
			}
			
			var registry = JsonUtils.Deserialize(jsonText) 
				?? new RegistryData() { components = new RegisteredComponent[] { } };

			var componentSetBuilder = new StringBuilder();
			var componentGetBuilder = new StringBuilder();
			var componentTypeBuilder = new StringBuilder();
			
			foreach (var component in registry.components)
			{
				var propertiesSetBuilder = new StringBuilder();
				var propertiesGetBuilder = new StringBuilder();
				var propertiesTypeBuilder = new StringBuilder();

				foreach (var property in component.properties)
				{
					propertiesSetBuilder.Append(
						DictionaryPropertySet
							.Replace(PropertyName, property.name)
							.Replace(PropertyType, property.type)
							.Replace(ComponentType, component.type)
					);
					
					propertiesGetBuilder.Append(
						DictionaryPropertyGet
							.Replace(PropertyName, property.name)
							.Replace(PropertyType, property.type)
							.Replace(ComponentType, component.type)
					);
			
					propertiesTypeBuilder.Append(
						DictionaryPropertyType
							.Replace(PropertyName, property.name)
							.Replace(PropertyType, property.type)
					);
				}
			
				componentSetBuilder.Append(
					DictionaryComponentSet
						.Replace(ComponentType, component.type)
						.Replace(DictionaryElements, propertiesSetBuilder.ToString()
					)
				);
				
				componentGetBuilder.Append(
					DictionaryComponentGet
						.Replace(ComponentType, component.type)
						.Replace(DictionaryElements, propertiesGetBuilder.ToString()
					)
				);
				
				componentTypeBuilder.Append(
					DictionaryComponentType
						.Replace(ComponentType, component.type)
						.Replace(DictionaryElements, propertiesTypeBuilder.ToString()
					)
				);
			}
			
			var code = FileTemplate
				.Replace(ClassNameTag, ClassName)
				.Replace(NameSpaceTag, NameSpace)
				.Replace(GenerationDateTag, System.DateTime.Now.ToString("F"))
				.Replace(DictionarySetTeg, componentSetBuilder.ToString())
				.Replace(DictionaryGetTag, componentGetBuilder.ToString())
				.Replace(DictionaryTypeTag, componentTypeBuilder.ToString())
				.Replace(SourceFileTag, jsonText);

			context.AddSource(
				ClassName, 
				SourceText.From(code, Encoding.UTF8)
			);
		}

		public void Initialize(GeneratorInitializationContext context) { }

		private const string NameSpaceTag = "{NAME_SPACE}";
		private const string ClassNameTag = "{CLASS_NAME}";
		private const string GenerationDateTag = "{GENETATION_DATE}";
		private const string DictionarySetTeg = "{DICTIONARY_SET}";
		private const string DictionaryGetTag = "{DICTIONARY_GET}";
		private const string DictionaryTypeTag = "{DICTIONARY_TYPE}";
		private const string SourceFileTag = "{SOURCE_FILE}";
		
		private const string FileTemplate = 
@"
using System;
using System.Collections.Generic;

// ReSharper disable PossibleNullReferenceException
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable UnusedMember.Local
// ReSharper disable RedundantNameQualifier
// ReSharper disable StringLiteralTypo

namespace Monogum.BricksBucket.PropertyRefs.Hardwire
{
	/// <summary>
	/// Registered types.
	/// 
	/// <autogenerated>
	/// 
	/// This code was generated by a tool.
	/// Changes to this file may cause incorrect behavior and will
	/// be lost if the code is regenerated again.
	/// 
	/// </autogenerated>
	/// 
	/// ----------------------------------------------------------
	/// Code generated on {GENETATION_DATE}
	/// ----------------------------------------------------------
	///
	/// By Javier Garc√≠a.
	/// </summary>
	public static partial class {CLASS_NAME}
	{
		public static bool CodeGenerationEnabled = true;

		internal static Dictionary<string, Dictionary<string, Action<object, object>>> Set { get; }

		internal static Dictionary<string, Dictionary<string, Func<object, object>>> Get { get; }

		internal static Dictionary<string, Dictionary<string, Type>> PropertyType { get; }

		static {CLASS_NAME}()
		{
			Set = new Dictionary<string, Dictionary<string, Action<object, object>>>()
			{
				{DICTIONARY_SET}
			};
			
			Get = new Dictionary<string, Dictionary<string, Func<object, object>>>()
			{
				{DICTIONARY_GET}
			};
			
			PropertyType = new Dictionary<string, Dictionary<string, Type>>()
			{
				{DICTIONARY_TYPE}
			};
		}

		public static bool ContainsComponent(UnityEngine.Object component)
		{
			if (component == null) { return false; }

			var componentName = component.GetType().FullName;
			if (string.IsNullOrWhiteSpace(componentName)) { return false; }

			if (Get == null || Set == null) { return false; }

			return Set.ContainsKey(componentName)
				&& Get.ContainsKey(componentName);
		}

		public static bool ContainsProperty(UnityEngine.Object component, string propertyName)
		{
			if (component == null) { return false; }

			if (!ContainsComponent(component)) { return false; }

			var componentName = component.GetType().FullName;

			if (string.IsNullOrWhiteSpace(componentName) || string.IsNullOrWhiteSpace(propertyName))
			{
				return false;
			}

			return Set[componentName].ContainsKey(propertyName)
				&& Get[componentName].ContainsKey(propertyName);
		}

		public static Type GetPropertyType(UnityEngine.Object component, string propertyName)
		{
			if (!ContainsProperty(component, propertyName)) { return null; }

			var componentName = component.GetType().FullName;

			return PropertyType[componentName][propertyName];
		}

		public static object GetValue(UnityEngine.Object component, string propertyName)
		{
			if (!ContainsProperty(component, propertyName)) { return null; }

			var componentName = component.GetType().FullName;

			return Get[componentName][propertyName](component);
		}

		public static void SetValue(UnityEngine.Object component, string propertyName, object value)
		{
			if (!ContainsProperty(component, propertyName)) { return; }

			var componentName = component.GetType().FullName;

			Set[componentName][propertyName](component, value);
		}
	}
}

/*

* SOURCE FILE *

{SOURCE_FILE}

*/
";

		private const string ComponentType = "{COMPONENT_TYPE}";
		private const string DictionaryElements = "{DICTIONARY_ELEMENTS}";

		private const string DictionaryComponentSet = 
				@"{
					#region {COMPONENT_TYPE}
					""{COMPONENT_TYPE}"",
					new Dictionary<string, Action<object, object>>
					{      
						{DICTIONARY_ELEMENTS}
					}
					#endregion
				},";
		
		
		private const string DictionaryComponentGet = 
			@"{
					#region {COMPONENT_TYPE}

					""{COMPONENT_TYPE}"",
					new Dictionary<string, Func<object, object>>
					{
						{DICTIONARY_ELEMENTS}
					}
					#endregion
				},";
		
		private const string DictionaryComponentType = 
			@"{
					#region {COMPONENT_TYPE}

					""{COMPONENT_TYPE}"",
					new Dictionary<string, Type>
					{
						{DICTIONARY_ELEMENTS}
					}

					#endregion
				},";

		private const string PropertyName = "{PROPERTY_NAME}";
		private const string PropertyType = "{PROPERTY_TYPE}";

		private const string DictionaryPropertySet = 
						@"{
							""{PROPERTY_NAME}"",
							(component, value) => (component as {COMPONENT_TYPE})
								.{PROPERTY_NAME} = ({PROPERTY_TYPE}) value
						},";
		
		private const string DictionaryPropertyGet = 
						@"{
							""{PROPERTY_NAME}"",
							(component) => (component as {COMPONENT_TYPE}).{PROPERTY_NAME}
						},";
		
		
		private const string DictionaryPropertyType = 
						@"{
							""{PROPERTY_NAME}"",
							typeof({PROPERTY_TYPE})
						},";
	}
}